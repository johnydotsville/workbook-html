<!DOCTYPE html>
<html>
<head>
    <title></title>
    <link rel='stylesheet' href='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css'>
    <script src='https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js'></script>
    <script>hljs.highlightAll();</script>
    <style>* {
  box-sizing: border-box;
}


html {
  scroll-behavior: smooth;

  text-align: justify;       /* Выравнивание по ширине */
  text-align-last: left;     /* Последняя строка - по левому краю */
  hyphens: auto;             /* Перенос слов (опционально) */
}


body {
  margin: 0;
  padding: 0;
  background-color: #1E1E1E;
}


h1 {
  font-size: 2.5rem;
}


.content {
  max-width: 800px;
  padding: 20px;
  margin: 0 auto;
  background-color: #FFC6A3;
}</style>
</head>
<body>
  <section class="content">
    <h1 id="объекты">Объекты</h1>
    <h2 id="создание-объекта">Создание объекта</h2>
    <ul>
    <li>Способы создания объекта
    <ul>
    <li>Объектный литерал { } - 99% случаев, когда надо просто описать
    объект с данными</li>
    <li>Object.create() - редкие кейсы, вроде создания объекта без
    прототипа или с явным указанием прототипа</li>
    <li>Функция конструктор (через оператор new) - обычно когда речь
    идет о создании экземпляра класса</li>
    </ul></li>
    </ul>
    <h2 id="прототип-объекта">Прототип объекта</h2>
    <ul>
    <li>Прототипное наследование</li>
    <li>Собственные и наследованные свойства</li>
    <li>Механизм поиска свойства (сначала у себя &gt; потом в прототипе
    и далее по цепочке прототипов вверх)</li>
    </ul>
    <h2 id="свойства-объекта">Свойства объекта</h2>
    <h3 id="доступ-к-свойствам-объекта">Доступ к свойствам объекта</h3>
    <ul>
    <li>Когда знаешь имя свойства - через точку .</li>
    <li>Когда имя свойства вычисляется (например, лежит в переменной) -
    через квадратные скобки [ ]</li>
    </ul>
    <h3 id="проверить-есть-ли-у-объекта-свойство">Проверить, есть ли у
    объекта свойство</h3>
    <ul>
    <li>Проверять только собственные свойства - метод Object.hasOwn(obj,
    ‘foobar’)</li>
    <li>Проверять у себя и в прототипе - оператор in, (if (‘foobar’ in
    obj))</li>
    <li>Устаревшие нерекомендуемые способы
    <ul>
    <li>obj.hasOwnProperty(‘foobar’)</li>
    <li>if (obj.foobar !== undefined)</li>
    </ul></li>
    </ul>
    <h3 id="управление-свойствами">Управление свойствами</h3>
    <ul>
    <li>Добавить свойство объекту
    <ul>
    <li>Просто обратиться к свойству и положить в него значение, оно
    создастся если его не существует.</li>
    <li>Object.defineProperty() - один из нескольких методов для
    низкоуровневого влияния на свойства, их флаги для тонкой настройки и
    т.д. Нужно редко, гуглится по мере необходимости.</li>
    </ul></li>
    <li>Удалить свойство из объекта
    <ul>
    <li>Оператор delete, delete user.lastname или delete
    user[“lastname”]</li>
    </ul></li>
    </ul>
    <h3 id="геттеры-и-сеттеры">Геттеры и сеттеры</h3>
    <ul>
    <li>С виду выглядят как свойства (обращение без скобок()), хотя на
    самом деле это методы, в которых можно скрыть сложную логику
    установки  получения свойства.</li>
    <li>Когда полезно
    <ul>
    <li>Валидация значений</li>
    <li>Создание “Виртуальных” свойств - за Гможно скрыть логику сборки
    “виртуального свойства” из других свойств. Например, в объекте есть
    поля name и surname, можно сделать “виртуальное” свойство fullname,
    собрав его из name + surname.</li>
    </ul></li>
    </ul>
    <h2 id="обход-свойств-и-их-значений-в-объекте">Обход свойств и их
    значений в объекте</h2>
    <ul>
    <li>Части объекта можно получить как массивы и обойти:
    <ul>
    <li>Имена свойств - Object.keys(obj)</li>
    <li>Значения свойств - Object.values(obj)</li>
    <li>Пары “имя свойства - значение” - Object.entries(obj)
    <ul>
    <li>Массив из двух элементов [свойство, значение]</li>
    </ul></li>
    <li>Не путать с этими методами у Map, Set - там они возвращают
    iterable-объекты.</li>
    </ul></li>
    </ul>
    <h2 id="методы-объекта">Методы объекта</h2>
    <ul>
    <li>Методы - это обычные свойства, просто в них лежат функции.</li>
    <li>Как снабдить объект методом
    <ul>
    <li>Описать метод внутри объекта</li>
    <li>Добавить свойство объекту и положить туда функцию</li>
    </ul></li>
    <li>Практические советы
    <ul>
    <li>Разделяем данные и поведение: в объектах - только поля с
    данными, без методов; обработка - пишем функции, которые принимают
    эти объекты.</li>
    <li>Если нужно скомбинировать данные и поведение - используем
    классы.
    <ul>
    <li>P.S. Под капотом классы все равно трансформируются в
    объекты.</li>
    </ul></li>
    </ul></li>
    </ul>
    <h2 id="манипуляции-с-объектами">Манипуляции с объектами</h2>
    <h3 id="слияние-объектов-добавление-свойств-объекту">Слияние
    объектов, добавление свойств объекту</h3>
    <ul>
    <li>spread-оператор</li>
    <li>Object.assign(to, from1, from2) - не забывать, что метод
    мутирует “to”-объект</li>
    <li>Примеры
    <ul>
    <li>Слияние <code>const merged = { ...obj1, ...obj2 }</code> ,
    <code>const merged = Object.assign({}, obj1, obj2)</code></li>
    <li>Добавление свойств объекту
    <code>{ ...obj1, { name: "John" } }</code> ,
    <code>Object.assign(obj1, { name: "John" })</code></li>
    </ul></li>
    </ul>
    <h3 id="клонирование-объекта">Клонирование объекта</h3>
    <ul>
    <li>Способы создать независимую копию объекта
    <ul>
    <li>Простое одноуровневое копирование (поверхностное)
    <ul>
    <li>spread-оператор - хорош для копирования простых объектов с
    данными без методов, геттеров  сеттеров.
    <code>const copy = { ...obj }</code></li>
    <li>Object.assign,
    <code>const copy = Object.assign({}, obj)</code></li>
    </ul></li>
    <li>Глубокое копирование
    <ul>
    <li>window.structuredClone(obj) - нативный способ, работает в
    современных браузерах.</li>
    <li>Lodash.cloneDeep - сторонняя библиотека, самая
    распространенная.</li>
    </ul></li>
    </ul></li>
    </ul>
    <h3 id="сравнение-объектов">Сравнение объектов</h3>
    <ul>
    <li>Происходит по ссылке, оператор === сравнивает не содержимое
    объектов, а ссылку.</li>
    <li>Если нужно сравнение по содержимому - делается через библиотеки
    (например, lodash.isEqual)</li>
    </ul>
  </section>
</body>
</html>